#!/usr/bin/env uv run
# /// script
# dependencies = [
#   "jinja2",
#   "click"
# ]
# ///

from pathlib import Path
from typing import NamedTuple, SupportsIndex

import click
from jinja2 import Template

EXPR_RULES = """
    Assign   : Token name, Expr value
    Binary   : Expr left, Token operator, Expr right
    Grouping : Expr expression
    Literal  : Object value
    Logical  : Expr left, Token operator, Expr right
    Unary    : Token operator, Expr right
    Variable : Token name
"""

STMT_RULES = """
    Block      : List<Stmt> statements
    Expression : Expr expression
    If         : Expr condition, Stmt thenBranch, Stmt elseBranch
    Print      : Expr expression
    Var        : Token name, Expr initializer
    While      : Expr condition, Stmt body
"""

AST_TEMPLATE = """
/*
 * THIS CODE WAS GENERATED BY generate_ast.py.
 * DO NOT EDIT BY HAND!
 */
package uk.co.judy.lox;

import java.util.List;

abstract class {{base_name}} {
    interface Visitor<R> {
        {%- for t in types %}
        R visit{{t.name}}{{base_name}}({{t.name}} {{base_name | lower}});
        {%- endfor %}
    }

    abstract <R> R accept(Visitor<R> visitor);
    {% for t in types %}
    static class {{t.name}} extends {{base_name}} {
        {{t.name}}({{t.java_param_list}}) {
            {%- for f in t.fields %}
            this.{{f.name}} = {{f.name}};
            {%- endfor %}
        }

        @Override
        <R> R accept(Visitor<R> visitor) {
            return visitor.visit{{t.name}}{{base_name}}(this);
        }
        {% for f in t.fields %}
        final {{f.type}} {{f.name}};
        {%- endfor %}
    }
    {% endfor %}
}
""".lstrip()


class Field(NamedTuple):
    type: str
    name: str

    @classmethod
    def from_str(cls, pair: str) -> "Field":
        return Field(*ws_split(pair, " ", 1))

    @property
    def java_def(self):
        return f"{self.type} {self.name}"


class Type(NamedTuple):
    name: str
    fields: list[Field]

    @classmethod
    def from_rule(cls, rule: str) -> "Type":
        name, f_string = ws_split(rule, ":", 1)
        return cls(name, [Field.from_str(pair) for pair in ws_split(f_string, ",")])

    @property
    def java_param_list(self):
        return ", ".join(field.java_def for field in self.fields)


def ws_split(
    input: str, sep: str | None = None, maxsplit: SupportsIndex = -1
) -> list[str]:
    """The same as str.split(), but strips surrounding whitespace from all resulting elements."""
    return [item.strip() for item in input.strip().split(sep, maxsplit)]


def define_ast(output_dir: Path, name: str, types: list[str]):
    template = Template(AST_TEMPLATE)
    path = output_dir / f"{name}.java"
    path.write_text(
        template.render(base_name=name, types=[Type.from_rule(rule) for rule in types])
    )


def prepare_rules(rules: str):
    return [line.strip() for line in rules.strip().splitlines()]


@click.command()
@click.argument(
    "output_dir",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, path_type=Path),
)
def main(output_dir: Path):
    define_ast(output_dir, "Expr", prepare_rules(EXPR_RULES))
    define_ast(output_dir, "Stmt", prepare_rules(STMT_RULES))


if __name__ == "__main__":
    main()  # type: ignore
